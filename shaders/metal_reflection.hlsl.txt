// Metal Reflection Shader - Efectos metálicos con reflexiones cúbicas
// Compatible con DirectX 9 - Shader Model 3.0

// Matrices
float4x4 WorldMatrix;
float4x4 ViewMatrix;
float4x4 ProjectionMatrix;
float4x4 WorldViewProj;

// Posición de la cámara
float3 CameraPosition = float3(0.0f, 0.0f, 0.0f);

// Propiedades del metal
float4 BaseColor = float4(0.7f, 0.7f, 0.8f, 1.0f);
float4 SpecularColor = float4(1.0f, 1.0f, 1.0f, 1.0f);
float Metallic = 1.0f;          // 0.0 = dieléctrico, 1.0 = metálico
float Roughness = 0.1f;         // 0.0 = espejo perfecto, 1.0 = rugoso
float FresnelPower = 5.0f;
float ReflectionIntensity = 1.0f;
float EnvironmentIntensity = 1.0f;

// Iluminación
float3 LightDirection = float3(0.0f, -1.0f, 0.0f);
float4 LightColor = float4(1.0f, 1.0f, 1.0f, 1.0f);

// Texturas
texture DiffuseTexture;     // Textura base del metal
texture NormalTexture;      // Mapa de normales
texture RoughnessTexture;   // Mapa de rugosidad
texture MetallicTexture;    // Mapa metálico
textureCUBE EnvironmentMap; // Cube map para reflexiones

// Samplers
sampler DiffuseSampler = sampler_state
{
    Texture = <DiffuseTexture>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = WRAP;
    AddressV = WRAP;
};

sampler NormalSampler = sampler_state
{
    Texture = <NormalTexture>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = WRAP;
    AddressV = WRAP;
};

sampler RoughnessSampler = sampler_state
{
    Texture = <RoughnessTexture>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = WRAP;
    AddressV = WRAP;
};

sampler MetallicSampler = sampler_state
{
    Texture = <MetallicTexture>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = WRAP;
    AddressV = WRAP;
};

samplerCUBE EnvironmentSampler = sampler_state
{
    Texture = <EnvironmentMap>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
    AddressU = CLAMP;
    AddressV = CLAMP;
    AddressW = CLAMP;
};

struct VS_INPUT
{
    float3 Position : POSITION;
    float3 Normal : NORMAL;
    float2 TexCoord : TEXCOORD0;
    float3 Tangent : TANGENT;
    float3 Binormal : BINORMAL;
};

struct VS_OUTPUT
{
    float4 Position : POSITION;
    float2 TexCoord : TEXCOORD0;
    float3 Normal : TEXCOORD1;
    float3 WorldPos : TEXCOORD2;
    float3 Tangent : TEXCOORD3;
    float3 Binormal : TEXCOORD4;
    float3 ViewDirection : TEXCOORD5;
    float3 ReflectionVector : TEXCOORD6;
};

// Función de Fresnel (Schlick approximation)
float3 FresnelSchlick(float cosTheta, float3 F0)
{
    return F0 + (1.0f - F0) * pow(1.0f - cosTheta, FresnelPower);
}

// Distribution Function (GGX/Trowbridge-Reitz)
float DistributionGGX(float3 N, float3 H, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0f);
    float NdotH2 = NdotH * NdotH;

    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0f) + 1.0f);
    denom = 3.14159265f * denom * denom;

    return num / denom;
}

// Geometry Function (Smith)
float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0f);
    float k = (r * r) / 8.0f;

    float num = NdotV;
    float denom = NdotV * (1.0f - k) + k;

    return num / denom;
}

float GeometrySmith(float3 N, float3 V, float3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0f);
    float NdotL = max(dot(N, L), 0.0f);
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);

    return ggx1 * ggx2;
}

VS_OUTPUT VS(VS_INPUT input)
{
    VS_OUTPUT output;

    // Transformar posición
    float4 worldPos = mul(float4(input.Position, 1.0f), WorldMatrix);
    output.Position = mul(worldPos, mul(ViewMatrix, ProjectionMatrix));
    output.WorldPos = worldPos.xyz;

    // Pasar coordenadas de textura
    output.TexCoord = input.TexCoord;

    // Transformar vectores al espacio del mundo
    output.Normal = normalize(mul(input.Normal, (float3x3)WorldMatrix));
    output.Tangent = normalize(mul(input.Tangent, (float3x3)WorldMatrix));
    output.Binormal = normalize(mul(input.Binormal, (float3x3)WorldMatrix));

    // Calcular dirección de vista
    output.ViewDirection = normalize(CameraPosition - worldPos.xyz);

    // Calcular vector de reflexión
    output.ReflectionVector = reflect(-output.ViewDirection, output.Normal);

    return output;
}

float4 PS(VS_OUTPUT input) : COLOR
{
    // Normalizar vectores interpolados
    float3 N = normalize(input.Normal);
    float3 V = normalize(input.ViewDirection);
    float3 L = normalize(-LightDirection);
    float3 H = normalize(L + V);

    // Obtener propiedades de las texturas
    float4 albedo = tex2D(DiffuseSampler, input.TexCoord) * BaseColor;

    // Normal mapping
    float3 normalMap = tex2D(NormalSampler, input.TexCoord).xyz * 2.0f - 1.0f;
    float3x3 TBN = float3x3(input.Tangent, input.Binormal, N);
    N = normalize(mul(normalMap, TBN));

    // Propiedades del material
    float roughness = tex2D(RoughnessSampler, input.TexCoord).r * Roughness;
    float metallic = tex2D(MetallicSampler, input.TexCoord).r * Metallic;

    // Recalcular reflection vector con normal corregida
    float3 R = reflect(-V, N);

    // PBR Calculations
    float3 F0 = lerp(float3(0.04f, 0.04f, 0.04f), albedo.rgb, metallic);

    // Cook-Torrance BRDF
    float NDF = DistributionGGX(N, H, roughness);
    float G = GeometrySmith(N, V, L, roughness);
    float3 F = FresnelSchlick(max(dot(H, V), 0.0f), F0);

    float3 kS = F;
    float3 kD = float3(1.0f, 1.0f, 1.0f) - kS;
    kD *= 1.0f - metallic;

    float3 numerator = NDF * G * F;
    float denominator = 4.0f * max(dot(N, V), 0.0f) * max(dot(N, L), 0.0f) + 0.001f;
    float3 specular = numerator / denominator;

    // Outgoing radiance
    float NdotL = max(dot(N, L), 0.0f);
    float3 Lo = (kD * albedo.rgb / 3.14159265f + specular) * LightColor.rgb * NdotL;

    // Environment mapping para reflexiones
    float roughnessMip = roughness * 6.0f; // Asumiendo 7 niveles de mip
    float4 envColor = texCUBElod(EnvironmentSampler, float4(R, roughnessMip));

    // Fresnel para environment mapping
    float3 F_env = FresnelSchlick(max(dot(N, V), 0.0f), F0);
    float3 kS_env = F_env;
    float3 kD_env = 1.0f - kS_env;
    kD_env *= 1.0f - metallic;

    // Ambient lighting
    float3 irradiance = envColor.rgb * 0.3f; // Simplificado
    float3 diffuse = irradiance * albedo.rgb;

    // Reflection
    float3 prefilteredColor = envColor.rgb * EnvironmentIntensity;
    float2 envBRDF = float2(F_env.x, (1.0f - roughness)); // Simplificado
    float3 reflection = prefilteredColor * (F_env * envBRDF.x + envBRDF.y) * ReflectionIntensity;

    float3 ambient = (kD_env * diffuse + reflection);

    // Color final
    float3 color = ambient + Lo;

    // Tone mapping simple
    color = color / (color + float3(1.0f, 1.0f, 1.0f));

    // Gamma correction
    color = pow(color, 1.0f / 2.2f);

    return float4(color, albedo.a);
}

// Técnicas
technique MetalTechnique
{
    pass P0
    {
        VertexShader = compile vs_3_0 VS();
        PixelShader = compile ps_3_0 PS();

        CullMode = CCW;
        ZEnable = true;
        ZWriteEnable = true;
        AlphaBlendEnable = false;
    }
}

technique MetalReflective
{
    pass P0
    {
        VertexShader = compile vs_3_0 VS();
        PixelShader = compile ps_3_0 PS();

        CullMode = CCW;
        ZEnable = true;
        ZWriteEnable = true;
        AlphaBlendEnable = true;
        SrcBlend = SrcAlpha;
        DestBlend = InvSrcAlpha;
    }
}
